# TP 3

## Objectifs :

- Mettre en place une Base de Donn√©es avec EF Core
- Lier les op√©rations CRUD avec la base de donn√©es

Nous allons utiliser **Entity Framework Core**.

Entity FrameWork Core est un outil impl√©mentant l'Objet Relationship Mapping (ORM). On dit plus simplement que EF Core est un ORM.

Un ORM permet de faire un lien entre des objets dans le sens programmation orient√© objet, et des entit√©s dans le sens base de donn√©es. 
Ainsi, une `class` en dotnet peut facilement √™tre convertie en une `table` SQL.

![](img/efcore.jfif)

Enfin, cela √©limine le besoin d'√©crire √† la main les requ√™tes SQL, l'outil ayant √† sa disposition des moyens d'effectuer une requ√™te √† partir de directives propres √† dotnet.

> ‚ö†Ô∏è Ne confondez pas `Entity Framework Core` de `Entity Framework`. De la m√™me mani√®re que Microsoft a voulu r√©√©crire le .NET Framework vers .NET Core, les ing√©nieurs de Microsoft ont r√©√©cri Entity Framework (aussi appel√© EF6) vers Entity Framework Core. Entity Framework Core est la nouvelle version d'Entity Framework apr√®s EF6. Ils n'ont pas les m√™mes designs et leur utilisation se fait diff√©remment.

## (1) Mettre en place un DbContext

D√©marrez un terminal √† la racine du projet. 

Installer le package `EntityFrameworkCore` √† l'aide de la commande suivante : 

````
dotnet add package Microsoft.EntityFrameworkCore
````
Installer ensuite le package `Sqlite`, un l√©ger fournisseur de base de donn√©es.
```
dotnet add package Microsoft.EntityFrameworkCore.Sqlite
```

Dans le `Program.cs`, enregistrer un contexte de base de donn√©es. Ajoutez la ligne 

````csharp
builder.Services.AddSwaggerGen(); // existant

builder.Services.AddDbContext<PokemonContext>(options => options.UseSqlite("Data Source=pokemons.db")); // √† ajouter

var app = builder.Build(); // existant
````

`PokemonContext` ne compile pas, nous allons s'en occuper.

Cr√©ez un fichier `Repositories/PokemonContext.cs` : 

````csharp
using Microsoft.EntityFrameworkCore;

public class PokemonContext : DbContext
{
    public PokemonContext(DbContextOptions<PokemonContext> dbContextOptions) : base(dbContextOptions)
    {
    }

    public DbSet<Pokemon> Pokemons { get; set; } = default!;
}
````

> üí° Un `DbContext` sert √† faire une session avec la base de donn√©es. C'est par ce fichier que EF Core va faire des query et sauvegarder les instances des entit√©s.

> üí° `public DbSet<Pokemon> Pokemons` permet de d√©clarer √† EF Core que notre Model `Pokemon.cs` et ses propri√©t√©s doivent √™tre mapp√©s √† une table SQL, qui aura (par d√©faut) le nom... Pokemons.

Ajoutons des donn√©es √† notre (future) Base, via EF Core.

Tout d'abord, rendons notre liste de Pok√©mons `static` pour pouvoir y acc√©der depuis l'ext√©rieur de la classe. 

> üí° Pour rappel, quand une variable est rendue `static`, une seule et m√™me copie de cette variable est cr√©√©e. Les variables `static` sont acc√©d√©es avec le nom de la classe, et donc une instance de la classe n'est pas requise. Par exemple, la variable static Pokemons sera accessible comme ceci : `PokemonsSources.Pokemons`   

`Services/PokemonsSources.cs` : 

````csharp
public static List<Pokemon> Pokemons = new List<Pokemon>
....
````

Revenez √† `Repositories/PokemonContext.cs`, ajoutez :

````csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
        var data = PokemonsSources.Pokemons.Append(new Pokemon
        {
            Id = 10,
            Name = "Caterpie",
            Description = "Its short feet are tipped with suction pads that enable it to tirelessly climb slopes and walls.",
            Type = PokemonType.Bug,
            PictureUrl = "https://img.pokemondb.net/artwork/large/caterpie.jpg"
        });

    modelBuilder.Entity<Pokemon>()
        .HasData(data);
}
````

> üí° La m√©thode `OnModelCreating(ModelBuilder modelBuilder)` est utilis√©e par le framework EF Core. A un moment donn√© dans l'√©x√©cution, le framework appelle cette m√©thode, et √©x√©cute les directives qui y sont pr√©sentes. Par d√©faut, la m√©thode ne contient rien, mais on peut l'`override` pour indiquer que des op√©rations sont √† faire. 

> üí° Ce genre de comportement d'une m√©thode, de pouvoir surcharger un comportement mais que cela reste optionnel, est caract√©ristique d'une m√©thode avec le mot cl√© `virtual` : c'est une m√©thode qui poss√®de un comportement par d√©faut, mais qui peut √™tre r√©√©crit par la classe qui √©tend (d√©finition expos√©e, impl√©mentation requise). Les autres mot-cl√©s de comportement sont `abstract` ou encore `interface`.

# (2) Faire un GET pour r√©cup√©rer les Pok√©mons de la BDD

Cr√©ons un nouveau controller, `Controllers/PokemonDbController.cs` :

````csharp
using Microsoft.AspNetCore.Mvc;

namespace PokeAPIPolytech.Controllers;

[ApiController]
[Route("[controller]")]
public class PokemonsDbController : ControllerBase
{
    private readonly ILogger<PokemonsController> _logger;
    private readonly IPokemonsDbSources _pokemonsDbSources;

    public PokemonsDbController(
        ILogger<PokemonsController> logger,
        IPokemonsDbSources pokemonsDbSources)
    {
        _logger = logger;
        _pokemonsDbSources = pokemonsDbSources;
    }

    [HttpGet("All")]
    public IEnumerable<Pokemon> GetAllPokemons()
    {
        return _pokemonsDbSources.GetAll();
    }
}
````

Cr√©ons le service `Services/IPokemonsDbSources.cs`

````csharp
public interface IPokemonsDbSources
{
    IEnumerable<Pokemon> GetAll();
}
````

Puis le service qui l'impl√©mente, `Services/PokemonsDbSources.cs`

````csharp
public class PokemonsDbSources : IPokemonsDbSources
{
    public IEnumerable<Pokemon> GetAll()
    {
        throw new NotImplementedException();
    }
}
````

N'oublions pas de le rajouter dans le dictionaire d'injection de d√©pendances :

`Program.cs`

````csharp
builder.Services.AddSingleton<IPokemonsSources, PokemonsSources>(); //existant
builder.Services.AddScoped<IPokemonsDbSources, PokemonsDbSources>();
````

Le service est pr√™t, nous pouvons lui injecter notre `DbContext` et remplir la m√©thode `GetAll()`

````csharp
using Microsoft.EntityFrameworkCore;

public class PokemonsDbSources : IPokemonsDbSources
{
    private readonly PokemonContext _dbContext;

    public PokemonsDbSources(
        PokemonContext context
    )
    {
        this._dbContext = context;
    }

    public IEnumerable<Pokemon> GetAll()
    {
        return this._dbContext.Pokemons
            .FromSqlRaw($"SELECT * FROM Pokemons")
            .ToList();
    }
}
````

Lancez le service, et tentez de faire un `GetAll()` avec le controller `PokemonsDbController`.

Vous devriez avoir une erreur : 

````
Microsoft.Data.Sqlite.SqliteException (0x80004005): SQLite Error 1: 'no such table: Pokemons'.
   at Microsoft.Data.Sqlite.SqliteException.ThrowExceptionForRC(Int32 rc, sqlite3 db)

   ....
````

> ‚ö†Ô∏è Effectivement, pour le moment, nous n'avons fait que d√©finir le lien EF Core entre la table SQL Pokemon et la classe .NET `Pokemon`. La table `Pokemons` elle, n'a pas encore √©t√© cr√©√©e. Pour comparer, il manque les directives SQL `CREATE TABLE Pokemons`...

## (3) Migration de la Base de donn√©es

EF Core vient avec un module dit de **migration** : il permet de faire √©voluer le sch√©ma de la base de donn√©es au cours du temps et du d√©veloppement.

De la m√™me mani√®re que nous avions d√©fini comment doit √™tre le lien entre classe .NET et SQL pour pouvoir faire des requ√™tes, EF Core permet de g√©n√©rer automatiquement le code permettant de d√©finir le sch√©ma d'une base de donn√©es, et de la faire √©voluer dans le temps.

![](img/ef%20core%20migrations.png)

Tout d'abord, ajoutons un package n√©cessaire

> `dotnet add package Microsoft.EntityFrameworkCore.Design`

Il faut maintenant installer l'outil `dotnet ef` :

> `dotnet tool install --global dotnet-ef`

V√©rifiez que l'outil est install√© avec 

> `dotnet ef`

Pour cr√©er notre premi√®re migration, il faut utiliser la commande

> `dotnet ef migrations add "Initial"`

Regardez dans vos dossiers : un nouveau dossier nomm√© Migrations a d√ª √™tre cr√©√©.

3 Fichiers sont pr√©sents : 
- [date]_Initial.cs
- [date]_Initial.Designer.cs
- PokemonContextModelSnapshot.cs

Les deux derniers fichiers sont des fichiers internes √† EF, oubliez-les.

En revanche ouvrez le premier fichier : il contient deux m√©thodes `Up` et `Down`

> üí° L'id√©e derri√®re ces m√©thodes est de pouvoir avancer ou reculer dans une suite de migrations : mettre √† jour une base de donn√©es depuis le d√©but jusqu'√† une migration N va demander √† EF d'ex√©cuter toutes les m√©thodes `Up` jusqu'√† la migration N cibl√©e (incluse).
> Dans l'autre sens, demander √† EF de revenir en arri√®re vers une migration plus ancienne va ex√©cuter les commandes `Down`.

> üí° Si on regarde dans le d√©tail les m√©thodes, on voit bien qu'il y a des directives en dotnet `CreateTable` ou `DropTable`, ce qui va nous permettre de faire √©voluer le sch√©ma de notre BD !

> ‚ö†Ô∏è Il est fortement conseill√© de ne pas toucher directement au code des fichiers sous le dossier `Migrations`, mais plut√¥t d'utiliser l'outil `dotnet ef`. Les fichiers sont du code g√©n√©r√©.

Nous avons notre script de migration, appliquons-le √† notre BD. La commande √† ex√©cuter est la suivante : 

> `dotnet ef database update`

Cela va mettre √† jour la BD vers la migration la plus r√©cente.

> üí° Si on voulait cibler une migration partiuli√®re, la commande aurait √©t√© `dotnet ef database update "MaMigration"` (sans la date, juste le nom)

> üí° Pour cibler la premi√®re migration, et en particulier les `Down`, la commande est `dotnet ef database update 0`

Vous avez peut √™tre remarqu√© la cr√©ation d'un nouveau fichier : `pokemons.db` √† la racine de votre projet. C'est votre base de donn√©es... Elle n'est pas lisible par un humain mais c'est dedans o√π les tables et les donn√©es sont d√©finies.

> üí° En temps normal, un projet professionnel utilise un vrai moteur de base de donn√©es, mais c'est complexe √† mettre en place dans le cadre des TP Polytech.

R√©essayez de relancer le service, et de requ√™ter des nouveaux pok√©mons : cela devrait fonctionner !

## (4) Ins√©rer un nouveau pok√©mon en Base de donn√©es

Cr√©ez un nouvel endpoint avec le verbe POST dans `PokemonsDbController.cs`.

Faites en sorte qu'il appelle la m√©thode `Insert()` de `PokemonsDbSources.cs`

`PokemonsDbSources.cs` : 

````csharp
public Pokemon Insert(CreatePokemonDto dto)
{
    var pokemon = new Pokemon
    {
        Id = dto.Id,
        Name = dto.Name,
        Description = dto.Description,
        PictureUrl = dto.PictureUrl,
        Type = dto.Type
    };

    var query = "INSERT INTO Pokemons (Id, Description, Name, PictureUrl, Type) VALUES ('"+pokemon.Id+"', '"+pokemon.Description+"', '"+pokemon.Name+"', '"+pokemon.PictureUrl+"', '"+pokemon.PictureUrl+"')";

    this._dbContext.Pokemons
        .FromSqlRaw(query)
        .ToList();

    return pokemon;
}
````

Testez pour voir si √ßa fonctionne.

## (5) R√©cup√©rer un pok√©mon par nom

Cr√©ez un nouvel endpoint dans `PokemonsDbController.cs`, qui permettra de r√©cup√©rer un pok√©mon par nom.

Puis dans `PokemonsDbSources.cs` : 

````csharp
public Pokemon GetByName(string name)
{
    var query = "SELECT * FROM Pokemons WHERE Name = '"+name+"'";

    return this._dbContext.Pokemons
        .FromSqlRaw(query)
        .ToList()
        .FirstOrDefault();
}
````

## (6) Relation Many to Many

Un pok√©mon poss√®de une liste d'attaques.
Une attaque peut √™tre apprise par plusieurs pok√©mons diff√©rents.

Nous sommes dans le cas d'une relation many-to-many (ou N-to-N). Nous pouvons d√©finir cette relation dans EF Core, et une migration fera le reste dans le sch√©ma de la base de donn√©es.

Cr√©ons une nouvelle entit√©, `Models/Ability.cs`

````csharp
namespace Models;

public class Ability
{
    public int Id { get; set; }
    public string Name { get; set; }

    public virtual ICollection<Pokemon> Pokemons { get; set; }
}
````

> üí° Ici, le mot cl√© `virtual` permet √† la collection `Pokemons` d'√™tre substitu√© dans une classe d√©rivant de Ability. 

> üí° Notez que le mot cl√© `virtual` n'est plus requis dans les versions r√©centes de EF Core. Cependant, je pr√©f√®re le garder, car cela montre √† la future personne relisant le code que cette `ICollection` est en r√©alit√© une liste de Pok√©mons venant d'une autre table SQL. Ability ne poss√®de pas dans sa table une liste de Pok√©mons.

Ajoutons une ligne dans `Pokemons.cs`

````csharp
    public virtual ICollection<Ability> Abilities { get; set; }
````

Rajoutons un DbSet dans `PokemonContext.cs`

````csharp
    public DbSet<Ability> Abilities { get; set; } = default!;
````

Ajoutez dans le `OnModelCreating()`

````csharp
var dataAbilities = new List<Ability>{
    new Ability{
        Id = 1,
        Name = "shield-dust"
    }
};

modelBuilder.Entity<Ability>()
    .HasData(dataAbilities);

modelBuilder.Entity<Pokemon>()
    .HasMany(pokemon => pokemon.Abilities)
    .WithMany(ab => ab.Pokemons)
    .UsingEntity(abPok => abPok
        .HasData(new 
            { PokemonsId = 10, AbilitiesId = 1 }
        )
    );
           
````
> üí° Cela ajoute la comp√©tence "shield-dust" au pok√©mon "Caterpie".

> üí° Une relation Many-to-Many utilise une table d'association entre deux entit√©s. C'est toujours le cas ici, mais EF Core nous le cache. Le `.UsingEntity(abPok => abPok...` configure des donn√©es que poss√©dera la table d'association.

Ptit `dotnet ef migrations add "Abilities"` into `dotnet ef database update`

(N'h√©sitez pas √† aller voir du c√¥t√© de la migration cr√©√©e...)

## (7) GET Abilities

Cr√©ez une m√©thode GET pour r√©cup√©rer toutes les Abilities de la base de donn√©es

> üí° Il est judicieux de modifier les m√©thodes GET existantes, par exemple de `[HttpGet("All")]` vers `[HttpGet("Pokemons/All")]`

> Vous avez probablement `null` en r√©sultat sur la liste des pok√©mons, nous allons nous en occuper plus tard...

## (8) Et si on tentait un truc

Lancez votre service.

Sur l'endpoint permettant de r√©cup√©rer un pok√©mon par nom, dans le champ demand√© par swagger, au lieu de mettre votre nom cibl√©, mettez plut√¥t

> `Bulbasaur';drop table Abilities--`

Maintenant, refaites en Get All Abilities.

**Que s'est-t'il pass√© ?**

Pour r√©parer, allez dans le fichier de migration `[date]_Abilities.cs`, commentez la ligne 

````csharp
            migrationBuilder.DropTable(
                name: "Abilities");
````

Effectuez

> `dotnet ef database update "Initial"`

D√©commentez la ligne, puis

> `dotnet ef database update`

## (9) Utilisation de Linq-to-SQL au lieu de SQL brut

Jusqu'√† pr√©sent, nous avons effectu√© des requ√™tes SQL Pur pour faire nos manipulations. 

Non seulement c'est laborieux √† √©crire, mais c'est aussi soumis √† des bugs et des failles de s√©curit√© catastrophiques.

Heureusement, EF Core est encore l√† pour nous (que ferions-nous sans lui ?). 

EF Core propose ce que l'on appelle des projections "Linq To SQL". Le principe est d'utiliser des directives Linq sur notre DbContext pour faire nos query SQL. EF Core se chargera de convertir la directive Linq en requ√™te SQL, nous enlevant la charge de r√©diger du SQL.

> üí° Linq ('Link' ou 'Lin-kiou') est une librairie officielle permettant de manipuler des listes au sens large. Or, un r√©sultat d'une query SQL reste une sorte de liste (nom officiel : `IQueryable`) : une requ√™te `SELECT` renvoie une liste de lignes d'une table.

> üí° Il s'utilise de cette mani√®re : `maListe.MonOp√©rationLinq()`. Consultez <https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault?view=net-7.0>

> üí° EF Core contient des providers Linq-To-SQL pour tous les moteurs de base de donn√©es populaires. Aussi, il propose des providers pour des bases de donn√©es non-relationnelles. Ainsi, vous pouvez aussi utiliser EF Core pour manipuler des collections Mongo, par exemple.

Nous allons r√©√©crire nos query SQL brut en Linq-to-SQL.

> Si vous le souhaitez, vous pouvez renommer les m√©thodes actuelles en autre chose, si vous voulez garder l'ancienne version.

`PokemonsDbSources.cs` : 

````csharp
public IEnumerable<Pokemon> GetAll()
{
    return this._dbContext.Pokemons
        .ToList();
}

public IEnumerable<Ability> GetAllAbilities()
{
    return this._dbContext.Abilities
        .ToList();
}

public Pokemon GetByName(string name)
{
    return this._dbContext.Pokemons
        .FirstOrDefault(pokemon => pokemon.Name.Equals(name));
}
````

... c'est tout pour les `SELECT` !

Si vous regardez dans la console lors des appels aux endpoints, on voit quelles sont les requ√™tes effectu√©es par EF Core.

Pour la m√©thode `Insert()`, c'est un peu diff√©rent :

````csharp
public Pokemon Insert(CreatePokemonDto dto)
{
    var pokemon = new Pokemon
    {
        Id = dto.Id,
        Name = dto.Name,
        Description = dto.Description,
        PictureUrl = dto.PictureUrl,
        Type = dto.Type
    };

    this._dbContext.Pokemons
        .Add(pokemon);

    this._dbContext.SaveChanges();

    return pokemon;
}
````

La m√©thode `this._dbContext.SaveChanges();` est importante, et est en lien avec un paradigme de EF Core. Faire `this._dbContext.Pokemons.Add(pokemon);` marque l'entit√© `pokemon` comme √©tant "√† ajouter" par EF Core. Tant que `this._dbContext.SaveChanges();` n'est pas appel√©, l'entit√© ne sera pas sauvegard√© dans la base.

C'est un √©quivalent aux commit des bases de donn√©es.

## (10) Includes

Lors du GetAllPokemons(), la liste des Abilities reste toujours √† null.

C'est d√ª au fait que les entit√©s Pok√©mons et Abilities se situent dans deux tables SQL diff√©rentes... ce qui veut en th√©orie dire qu'il faut requ√™ter deux fois la base de donn√©es, une pour la table Pok√©mon, et une pour la table Abilities. Et c'est sans compter les tables d'associations, qui permettent de faire du Many-to-Many !

C'est pour cela que, par d√©faut, les requ√™tes Linq-to-SQL ne vont pas aller chercher les donn√©es d'autres tables que celle vis√©e de base. Cependant, on peut indiquer que l'on veut faire un lien avec une autre table.

Modifions les m√©thodes : 

````csharp
public IEnumerable<Pokemon> GetAll()
{
    return this._dbContext.Pokemons
        .Include(pokemon => pokemon.Abilities)
        .ToList();
}

public IEnumerable<Ability> GetAllAbilities()
{
    return this._dbContext.Abilities
        .Include(ability => ability.Pokemons)
        .ToList();
}

public Pokemon GetByName(string name)
{
    return this._dbContext.Pokemons
        .Include(pokemon => pokemon.Abilities)
        .FirstOrDefault(pokemon => pokemon.Name.Equals(name));
}
````

Ajoutez aussi une ligne dans le `Program.cs`

````csharp
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers().AddJsonOptions(options =>
{
    options.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.Preserve;
});
````

D√©marrez le service. Gr√¢ce √† la directive `Include()`, EF Core va effectuer des requ√™tes de liaison sur la Base de donn√©es. Quelle type de liaison fait EF Core ?

## (11) Impl√©mentez un update et un delete d'un Pok√©mon sur la Base de donn√©es

Regardez les m√©thodes disponibles sur le `_dbContext` pour faire cela, et impl√©mentez aussi des nouveaux endpoints √† votre controlleur.

Une fois que c'est fait, vous avez votre CRUD de Pok√©mon qui est sauvegard√© dans une Base !

---
> ‚ò†Ô∏è Comme nous avons pu le constater, EF Core est un outil puissant. Il m√¢che beaucoup le travail de mod√©lisation de la base de donn√©es, les d√©butants en mod√©lisation peuvent facilement le manipuler pour cr√©er une base de donn√©es relationelle. 

> Cependant, il est important dans le travail d'un ing√©nieur de comprendre ce que l'outil fait et cr√©e. Nous avons la responsabilit√© de la cr√©ation du sch√©ma de la base, si quelque chose fonctionne mal c'est de notre ressort d'analyser et de trouver la r√©ponse au probl√®me. Chose impossible √† faire si nous n'avons pas les notions de mod√©lisation de base de donn√©es.
---

## (12) [Bonus √©tal√© sur le TP 2 et TP 3] Se brancher √† Pok√©API

Nous avons d√©fini en local des pok√©mons. Mais un service Web existe d√©j√†, qui expose tous les pok√©mons ! Il s'agit de <https://pokeapi.co/>

Ajoutez un nouveau controller : `PokeApiController.cs`. Et un nouveau service : `PokeApi.cs` (et `IPokeApi.cs`)

````csharp
using Microsoft.AspNetCore.Mvc;

namespace PokeAPIPolytech.Controllers;

[ApiController]
[Route("[controller]")]
public class PokeApiController : ControllerBase
{
    private readonly ILogger<PokeApiController> _logger;
    private readonly IPokeAPI _pokeAPI;

    public PokeApiController(
        ILogger<PokeApiController> logger,
        IPokeAPI pokeAPI)
    {
        _logger = logger;
        this._pokeAPI = pokeAPI;
    }
}
````

`Program.cs` :

````csharp
builder.Services.AddScoped<IPokeApi, PokeApi>();

builder.Services.AddHttpClient();
````

`PokeApi.cs`

````csharp
public class PokeApi : IPokeApi
{
    private readonly HttpClient _client;

    public PokeApi(HttpClient client)
    {
        _client = client;
    }
}
````

Utilisez ce dont vous avez vu dans ce TP pour cr√©er un endpoint GET GetByPokemonName(), qui ira chercher sur PokeApi le pok√©mon correspondant au nom entr√©.

> üí° HttpClient est l'outil dotnet permettant de faire des requ√™tes HTTP dans le code.

> üí° Vous pouvez vous aider de sites comme <https://json2csharp.com/> pour convertir un fichier JSON en classe dotnet. C'est particuli√®rement utile pour convertir un r√©sultat d'une requ√™te HTTP (qui est en JSON) en classes typ√©es dotnet.

## (13) Pok√©mon Favoris

Impl√©mentez une nouvelle entit√© permettant de mettre en favori des pok√©mons. Cr√©ez un nouveau controlleur et un nouveau service permettant d'ajouter/d'enlever un pok√©mon des favoris.

## (14) Encore plus ?

Sujet libre. Ajoutez au service ce que vous voulez, mais pensez √† bien mettre des commentaires pour ma compr√©hension.